## Простой онлайн магазин.

Это просто попытка расширить свои знания. Мои прошлые "[изыскания](https://github.com/Online-video-game-store/Online-Storage-Classic.git)" 
были основаны  на своей реализации сервера аутентификации и авторизации с протоколом `OAuth2`,
и на межсервисном взаимодействии посредством `Feign`.

Здесь в качестве сервера авторизации используется `Keycloak`. Обмен данными между
микросервисами по прежнему идет через `Feign`, но процедура оформления заказа
реализована в асинхронном стиле, через `RabbitMQ` (вариация паттерна `Сага`).

Поскольку после запуска процедуры оформления заказа браузер не дожидается ответа,
а продолжает заниматься своими делами, то для обратной связи с пользователем, когда
оформление заказа будет завершено, использовались `WebSocket` + `JavaScript`. Такая схема
никогда не подвешивает UI-браузера, независимо от времени оформления заказа.


### Особенности.

В отличие от классической схемы (где `OAuth2-клиент` работает с микросервисами через `Gateway-шлюз`),
здесь `Gateway` частично выполняет роль `OAuth2-клиента`. А если точнее, то переадресовывает запросы,
связанные с web-контентом, на микросервис `Web-Client`, который теперь стал обычным 
сервером ресурсов.

**Из плюсов**. Это позволило легко закрыть доступ к микросервисам, не предназначенных для
публичного доступа. Микросервисы безопасно общаются между собой через `Eureka`, не нагружая
понапрасну `Gateway`.

**Из минусов**. Классическая аутентификация `OAuth2-клиента` теперь не работает. `OAuth2-клиент`
за `Gateway` не может обеспечить необходимый перехват редиректа от сервера аутентификации и, соответственно,
не может обменять код на Jwt-токен. 

Поэтому, микросервис `Web-Client` - это теперь классический сервер ресурсов, а аутентификацию производит
сам `Gateway`, хотя и пришлось для этого сделать пару специфичных эндпоинтов.

Еще из неудобств - инклюды в шаблонах `Thymeleaf` не работают, поскольку пути 
перестали быть просто относительными (они ведь проходят через шлюз и `Eureka`). Пришлось учитывать
это в шаблонах и делать фильтр для конвертации путей.

Также теперь в `Java Script` нет доступа к аутентификационным данным пользователя, их
банально не пропускает `Gateway`. С одной стороны неплохо, с другой - приходится
учитывать это при создании `UI`.

Было бы проще сделать из `Gateway` полноценный `OAuth2-клиент`, но мне кажется не правильно
навешивать на шлюз еще и веб-интерфейс, это нарушает принцип единой ответственности.

Всё это было решено и прекрасно работает.


## Подготовка к работе.
Вначале [устанавливаем и настраиваем контейнер с программами Keycloak, MySQL и RabbitMQ](Docker.md)


## Переменные окружения.
Для развертывания в продакшн необходимо установить переменную среды окружения:
`OAUTH2_BASE_ISSUER_URI=<адрес сервера Keycloak>:порт`

Также необходимо задать пути для пользовательской авторизации:

`OAUTH2_BASE_AUTH_URI=<базовый адрес клиента>:порт`

Для Эврики:

`EUREKA_SERVER_URL=<адрес сервера Eureka>/eureka`

***Например***:
```
OAUTH2_BASE_ISSUER_URI=http://192.168.1.179:8080
OAUTH2_BASE_AUTH_URI=http://192.168.1.179:9000
EUREKA_SERVER_URL=http://192.168.1.179:7777/eureka
```


## Spring Cloud Bus + RabbitMQ (с Management Plugin)

Порт 5672 — стандартный порт для AMQP-протокола.

Порт 15672 — для веб-интерфейса RabbitMQ Management.

Админка соответственно: http://localhost:15672

Пароль и логин (задается в `.env.rabbitmq`): `admin`


## MySql
Настройки задаются в .env.mysql. 
Для ручного администрирования можно зайти под `root` в контейнере:
```shell
mysql -uroot -padmin
```

